{"version":3,"sources":["resources.js","engine.js","player.js","bonus.js","app.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"all.js","sourcesContent":["/* Resources.js\n * This is simply an image loading utility. It eases the process of loading\n * image files so that they can be used within your game. It also includes\n * a simple \"caching\" layer so it will reuse cached images if you attempt\n * to load the same image multiple times.\n */\n(function() {\n  const resourceCache = {};\n  const readyCallbacks = [];\n\n  /* This is the publicly accessible image loading function. It accepts\n     * an array of strings pointing to image files or a string for a single\n     * image. It will then call our private image loading function accordingly.\n     */\n  function load(urlOrArr) {\n    if (urlOrArr instanceof Array) {\n      /* If the developer passed in an array of images\n             * loop through each value and call our image\n             * loader on that image file\n             */\n      urlOrArr.forEach(function(url) {\n        _load(url);\n      });\n    } else {\n      /* The developer did not pass an array to this function,\n             * assume the value is a string and call our image loader\n             * directly.\n             */\n      _load(urlOrArr);\n    }\n  }\n\n  /* This is our private image loader function, it is\n     * called by the public image loader function.\n     */\n  function _load(url) {\n    if (resourceCache[url]) {\n      /* If this URL has been previously loaded it will exist within\n             * our resourceCache array. Just return that image rather\n             * re-loading the image.\n             */\n      return resourceCache[url];\n    } else {\n      /* This URL has not been previously loaded and is not present\n             * within our cache; we'll need to load this image.\n             */\n      const img = new Image();\n      img.onload = function() {\n        /* Once our image has properly loaded, add it to our cache\n                 * so that we can simply return this image if the developer\n                 * attempts to load this file in the future.\n                 */\n        resourceCache[url] = img;\n\n        /* Once the image is actually loaded and properly cached,\n                 * call all of the onReady() callbacks we have defined.\n                 */\n        if (isReady()) {\n          readyCallbacks.forEach(function(func) {\n            func();\n          });\n        }\n      };\n\n      /* Set the initial cache value to false, this will change when\n             * the image's onload event handler is called. Finally, point\n             * the image's src attribute to the passed in URL.\n             */\n      resourceCache[url] = false;\n      img.src = url;\n    }\n  }\n\n  /* This is used by developers to grab references to images they know\n     * have been previously loaded. If an image is cached, this functions\n     * the same as calling load() on that URL.\n     */\n  function get(url) {\n    return resourceCache[url];\n  }\n\n  /* This function determines if all of the images that have been requested\n     * for loading have in fact been properly loaded.\n     */\n  function isReady() {\n    let ready = true;\n    for (const k in resourceCache) {\n      if (resourceCache.hasOwnProperty(k) &&\n               !resourceCache[k]) {\n        ready = false;\n      }\n    }\n    return ready;\n  }\n\n  /* This function will add a function to the callback stack that is called\n     * when all requested images are properly loaded.\n     */\n  function onReady(func) {\n    readyCallbacks.push(func);\n  }\n\n  /* This object defines the publicly accessible functions available to\n     * developers by creating a global Resources object.\n     */\n  window.Resources = {\n    load: load,\n    get: get,\n    onReady: onReady,\n    isReady: isReady,\n  };\n})();\n","/* Engine.js\n * This file provides the game loop functionality (update entities and render),\n * draws the initial game board on the screen, and then calls the update and\n * render methods on your player and enemy objects (defined in your app.js).\n *\n * A game engine works by drawing the entire game screen over and over, kind of\n * like a flipbook you may have created as a kid. When your player moves across\n * the screen, it may look like just that image/character is moving or being\n * drawn but that is not the case. What's really happening is the entire \"scene\"\n * is being drawn over and over, presenting the illusion of animation.\n *\n * This engine makes the canvas' context (ctx) object globally available to make\n * writing app.js a little simpler to work with.\n */\n\n/* global allEnemies player Resources */\n\n(function(global) {\n    /* Predefine the variables we'll be using within this scope,\n     * create the canvas element, grab the 2D context for that canvas\n     * set the canvas elements height/width and add it to the DOM.\n     */\n    const doc = global.document;\n\n    const win = global.window;\n\n    const canvas = doc.createElement('canvas');\n\n\n    const ctx = canvas.getContext('2d');\n\n\n    let lastTime;\n\n    canvas.width = 1111;\n    canvas.height = 686;\n    doc.body.appendChild(canvas);\n\n    /**\n   * This function serves as the kickoff point for the game loop itself\n   * and handles properly calling the update and render methods.\n   * @return {void}\n   */\n    function main() {\n    /* Get our time delta information which is required if your game\n         * requires smooth animation. Because everyone's computer processes\n         * instructions at different speeds we need a constant value that\n         * would be the same for everyone (regardless of how fast their\n         * computer is) - hurray time!\n         */\n        const now = Date.now();\n\n\n        const dt = (now - lastTime) / 1000.0;\n\n        /* Call our update/render functions, pass along the time delta to\n         * our update function since it may be used for smooth animation.\n         */\n        update(dt);\n        render();\n\n        /* Set our lastTime variable which is used to determine the time delta\n         * for the next time this function is called.\n         */\n        lastTime = now;\n\n        /* Use the browser's requestAnimationFrame function to call this\n         * function again as soon as the browser is able to draw another frame.\n         */\n        win.requestAnimationFrame(main);\n    }\n\n    /** This function does some initial setup that should only occur once,\n     * particularly setting the lastTime variable that is required for the\n     * game loop.\n     * @return {void}\n     */\n    function init() {\n        reset();\n        lastTime = Date.now();\n        main();\n    }\n\n    /** This function is called by main (our game loop) and itself calls all\n     * of the functions which may need to update entity's data. Based on how\n     * you implement your collision detection (when two entities occupy the\n     * same space, for instance when your character should die), you may find\n     * the need to add an additional function call here. For now, we've left\n     * it commented out - you may or may not want to implement this\n     * functionality this way (you could just implement collision detection\n     * on the entities themselves within your app.js file).\n     * @param {int} dt The delta number.\n     * @return {void}\n     */\n    function update(dt) {\n        updateEntities(dt);\n    // checkCollisions();\n    }\n\n    /** This is called by the update function and loops through all of the\n     * objects within your allEnemies array as defined in app.js and calls\n     * their update() methods. It will then call the update function for your\n     * player object. These update methods should focus purely on updating\n     * the data/properties related to the object. Do your drawing in your\n     * render methods.\n     * @param {int} dt The delta number.\n     * @return {void}\n     */\n    function updateEntities(dt) {\n        allEnemies.forEach(function(enemy) {\n            enemy.update(dt);\n        });\n        player.update();\n    }\n\n    /** This function initially draws the \"game level\", it will then call\n     * the renderEntities function. Remember, this function is called every\n     * game tick (or loop of the game engine) because that's how games work -\n     * they are flipbooks creating the illusion of animation but in reality\n     * they are just drawing the entire screen over and over.\n     * @return {void}\n     */\n    function render() {\n    /* This array holds the relative URL to the image used\n         * for that particular row of the game level.\n         */\n        const rowImages = [\n            'images/water-block.png', // Top row is water\n            'images/stone-block.png', // Row 1 of 3 of stone\n            'images/stone-block.png', // Row 2 of 3 of stone\n            'images/stone-block.png', // Row 3 of 3 of stone\n            'images/stone-block.png', // Row 3 of 3 of stone\n            'images/stone-block.png', // Row 3 of 3 of stone\n            'images/grass-block.png', // Row 2 of 2 of grass\n        ];\n\n\n        const numRows = 7;\n\n\n        const numCols = 11;\n\n\n        let row; let col;\n\n        // Before drawing, clear existing canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        /* Loop through the number of rows and columns we've defined above\n         * and, using the rowImages array, draw the correct image for that\n         * portion of the \"grid\"\n         */\n        for (row = 0; row < numRows; row++) {\n            for (col = 0; col < numCols; col++) {\n                /* The drawImage function of the canvas' context element\n                 * requires 3 parameters: the image to draw, the x coordinate\n                 * to start drawing and the y coordinate to start drawing.\n                 * We're using our Resources helpers to refer to our images\n                 * so that we get the benefits of caching these images, since\n                 * we're using them over and over.\n                 */\n                ctx.drawImage(Resources.get(rowImages[row]), col * 101, row * 83);\n            }\n        }\n\n        renderEntities();\n    }\n\n    /** This function is called by the render function and is called on each game\n     * tick. Its purpose is to then call the render functions you have defined\n     * on your enemy and player entities within app.js\n     *  @return {void}\n     */\n    function renderEntities() {\n    /* Loop through all of the objects within the allEnemies array and call\n         * the render function you have defined.\n         */\n        allEnemies.forEach(function(enemy) {\n            enemy.render();\n        });\n\n        player.render();\n\n        bonus.render();\n    }\n\n    /** This function does nothing but it could have been a good place to\n     * handle game reset states - maybe a new game menu or a game over screen\n     * those sorts of things. It's only called once by the init() method.\n     * @return {void}\n     */\n    function reset() {\n    // noop\n    }\n\n    /* Go ahead and load all of the images we know we're going to need to\n     * draw our game level. Then set init as the callback method, so that when\n     * all of these images are properly loaded our game will start.\n     */\n    Resources.load([\n        'images/stone-block.png',\n        'images/water-block.png',\n        'images/grass-block.png',\n        'images/enemy-bug.png',\n        'images/char-artur.png',\n        'images/bonus-coffee.png',\n    ]);\n    Resources.onReady(init);\n\n    /* Assign the canvas' context object to the global variable (the window\n     * object when run in a browser) so that developers can use it more easily\n     * from within their app.js files.\n     */\n    global.ctx = ctx;\n})(this);\n","const initialPosition = {\n    x: 475,\n    y: 20 + 5*80,\n};\n\n// Our Player\nconst Player = function() {\n    this.x = initialPosition.x;\n    this.y = initialPosition.y;\n    this.score = 0;\n    this.sprite = 'images/char-artur.png';\n};\n\n// It is a method required by the game\nPlayer.prototype.update = function() {};\n\n// Draw the player on the screen\nPlayer.prototype.render = function() {\n    ctx.drawImage(Resources.get(this.sprite), this.x, this.y);\n};\n\n// Handle the input of the player, moving the character up, left, right or down\nPlayer.prototype.handleInput = function(keyCode) {\n    switch (keyCode) {\n    case 'left':\n        if (this.x > 0) {\n            this.x -= 101;\n            this.checkBonus();\n        }\n        break;\n    case 'up':\n        // if it is moving up, it shoudl check if it is the winning spot.\n        if (this.y > 0) {\n            this.y -= 83;\n            this.checkBonus();\n        }\n        this.checkIfWin();\n        break;\n    case 'right':\n        if (this.x < 1000) {\n            this.x += 101;\n            this.checkBonus();\n        }\n        break;\n    case 'down':\n        if (this.y < 420) {\n            this.y += 83;\n            this.checkBonus();\n        }\n        break;\n    }\n};\n\n// Check if the player is in the toppest place of the game\nPlayer.prototype.checkIfWin = function() {\n    if (this.y < 0) {\n        this.moveToBeginning();\n        this.score += 100;\n        rangeSpeed += 10;\n        clearInterval(enemyInterval);\n        if (timeBetweenEnemies > 400) {\n            timeBetweenEnemies -= 100;\n        }\n        createNewEnemy();\n        enemyInterval = setInterval(createNewEnemy, timeBetweenEnemies);\n        refreshScore();\n        // Show you win message\n        showPanel(700, 'you-win');\n    }\n};\n\n// Move the player to the beginning\nPlayer.prototype.moveToBeginning = function() {\n    this.x = initialPosition.x;\n    this.y = initialPosition.y;\n};\n\nPlayer.prototype.loosePoints = function() {\n    rangeSpeed -= 10;\n    timeBetweenEnemies += 100;\n    this.score -= 100;\n    refreshScore();\n    showPanel(700, 'you-loose');\n};\n\nPlayer.prototype.checkBonus = function() {\n    if (bonus.x + 75 > player.x && bonus.x - 75 < player.x\n\t\t&& bonus.y + 40 > player.y + 20 && bonus.y - 40 < player.y + 20) {\n        this.score += 50;\n        rangeSpeed += 4;\n        timeBetweenEnemies -= 40;\n        refreshScore();\n        showPanel(400, 'you-win-bonus');\n        bonus.moveAround();\n    }\n};\n\n\nfunction refreshScore() {\n    document.getElementById('score').innerHTML = player.score;\n};\n\nfunction showPanel(timeStamp, cssClass) {\n    document.getElementById(cssClass).style.opacity = '1';\n    setTimeout(function() {\n        document.getElementById(cssClass).style.opacity = '0';\n    }, timeStamp);\n};\n\n","/* exported Bonus */\nclass Bonus {\n    constructor() {\n        this.generateNewPosition();\n        this.image = 'images/bonus-coffee.png';\n    }\n\n    render() {\n        ctx.drawImage(Resources.get(this.image), this.x, this.y);\n    }\n\n    moveAround() {\n        this.generateNewPosition();\n        ctx.drawImage(Resources.get(this.image), this.x, this.y);\n    }\n\n    generateNewPosition() {\n        this.column = Math.trunc(Math.random() * 10);\n        this.row = Math.trunc(Math.random() * 4);\n        this.x = 50 + this.column * 101;\n        this.y = this.row * 80;\n    }\n}\n","const baseSpeed = 30;\n/* exported rangeSpeed timeBetweenEnemies */\nlet rangeSpeed = 70;\nlet timeBetweenEnemies = 3000;\n\n// Enemies our player must avoid\nconst Enemy = function(row, speed) {\n    this.x = 0;\n    this.y = 60 + row*80;\n    this.speed = speed;\n    this.sprite = 'images/enemy-bug.png';\n};\n\n// Update the enemy's position\n// Parameter: dt, a time delta between ticks\nEnemy.prototype.update = function(dt) {\n    this.x += this.speed*dt;\n    if (this.x + 75 > player.x && this.x - 75 < player.x\n\t\t&& this.y + 30 > player.y + 40 && this.y - 30 < player.y + 40) {\n        player.loosePoints();\n        player.moveToBeginning();\n    }\n};\n\n// Draw the enemy on the screen\nEnemy.prototype.render = function() {\n    ctx.drawImage(Resources.get(this.sprite), this.x, this.y);\n};\n\n\n// List all enemies\nconst allEnemies = [];\n\n/* exported enemyInterval */\n// Create new enemy every 3 seconds.\nlet enemyInterval = setInterval(createNewEnemy, timeBetweenEnemies);\n\n// create the first enemy\ncreateNewEnemy();\n\n\n/**\n * create new enemy with random position and speed\n * @return {void}\n */\nfunction createNewEnemy() {\n    const speed = Math.random()*rangeSpeed + baseSpeed;\n    const row = Math.trunc(Math.random()*5);\n    allEnemies.push(new Enemy(row, speed));\n}\n\n// create the player\nconst player = new Player();\n\n/* exported bonus */\nlet bonus = new Bonus();\n\ndocument.getElementById('score').innerHTML = player.score;\n\n// This listens for key presses and sends the keys to your\n// Player.handleInput() method.\ndocument.addEventListener('keyup', function(e) {\n    const allowedKeys = {\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down',\n    };\n\n    player.handleInput(allowedKeys[e.keyCode]);\n});\n"]}